class Solution {
    public int maxValue(int[][] events, int k) {
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));
        int n = events.length;
        Integer[][] memo = new Integer[n][k + 1];

        // Precompute next non-overlapping event index
        int[] next = new int[n];
        for (int i = 0; i < n; i++) {
            int lo = i + 1, hi = n;
            while (lo < hi) {
                int mid = (lo + hi) / 2;
                if (events[mid][0] > events[i][1]) {
                    hi = mid;
                } else {
                    lo = mid + 1;
                }
            }
            next[i] = lo;
        }

        return dfs(0, k, events, next, memo);
    }

    private int dfs(int i, int k, int[][] events, int[] next, Integer[][] memo) {
        if (i == events.length || k == 0) return 0;
        if (memo[i][k] != null) return memo[i][k];

        // Option 1: skip current event
        int skip = dfs(i + 1, k, events, next, memo);

        // Option 2: take current event
        int take = events[i][2] + dfs(next[i], k - 1, events, next, memo);

        return memo[i][k] = Math.max(skip, take);
    }
}
