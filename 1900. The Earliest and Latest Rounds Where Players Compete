import java.util.*;

class Solution {
    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
        Map<String, int[]> memo = new HashMap<>();
        List<Integer> players = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            players.add(i);
        }
        return dfs(players, firstPlayer, secondPlayer, 1, memo);
    }

    private int[] dfs(List<Integer> players, int fp, int sp, int round, Map<String, int[]> memo) {
        String key = players.toString();
        if (memo.containsKey(key)) return memo.get(key);

        int size = players.size();
        for (int i = 0; i < size / 2; i++) {
            int a = players.get(i);
            int b = players.get(size - 1 - i);
            if ((a == fp && b == sp) || (a == sp && b == fp)) {
                return new int[]{round, round};
            }
        }

        List<List<Integer>> nextRounds = new ArrayList<>();
        generateNext(players, fp, sp, 0, size - 1, new ArrayList<>(), nextRounds);

        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (List<Integer> next : nextRounds) {
            Collections.sort(next);
            int[] res = dfs(next, fp, sp, round + 1, memo);
            min = Math.min(min, res[0]);
            max = Math.max(max, res[1]);
        }

        memo.put(key, new int[]{min, max});
        return memo.get(key);
    }

    private void generateNext(List<Integer> players, int fp, int sp, int l, int r,
                              List<Integer> current, List<List<Integer>> results) {
        if (l > r) {
            results.add(new ArrayList<>(current));
            return;
        }

        if (l == r) {
            current.add(players.get(l));
            generateNext(players, fp, sp, l + 1, r, current, results);
            current.remove(current.size() - 1);
            return;
        }

        int a = players.get(l), b = players.get(r);
        if (a == fp || a == sp) {
            current.add(a);
            generateNext(players, fp, sp, l + 1, r - 1, current, results);
            current.remove(current.size() - 1);
        } else if (b == fp || b == sp) {
            current.add(b);
            generateNext(players, fp, sp, l + 1, r - 1, current, results);
            current.remove(current.size() - 1);
        } else {
            current.add(a);
            generateNext(players, fp, sp, l + 1, r - 1, current, results);
            current.remove(current.size() - 1);

            current.add(b);
            generateNext(players, fp, sp, l + 1, r - 1, current, results);
            current.remove(current.size() - 1);
        }
    }
}
